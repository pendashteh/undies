#!/usr/bin/env bash
#
#
# Usage:
# 1: call as argument for undies
# $ /path/to/undies -- /path/to/script.undies
#
# 2: source inside the script
# $ /path/to/script.undies
# $ tail /path/to/script.undies -n1
# > . undies
#
__=${__:-__}

__API=2

__err_fn_na=101 ;: 'function does not exists'

__confirm__=${__confirm__-1}

##
#
# parent__ () {
#   : 'put on'
#   child__ () {
#     : 'childish stuff'
#   }
#   __sub parent "$@"
#   : 'take off'
# }
# parent__subcommand () {
#   : '__app__ parent subcommand'
# }
#
__parent__=${__parent__:-''}

##
# If set to a non-empty value, will take the first argument as $__id__ and the 2nd as task
#
# + __id__='--'
# $ app [id] [task]
#
__id__=${__id__:-''}

function __help {
  help_var=$(j __ $__parent__ ${1} help)
  sed "s|__app__|$(__app)|g" <<<${!help_var}
}

function j () {
  sed "s|\s|$1|g" <<<${@:2}
}

function __app {
  : 'retrieves the app name, ideally the executed command.'
  basename $__app__
}

function __exec {
  : 'Usage: > __exec [bash commands] # prompts the commands for the user and executes them'
  echo "> $@"
  test ! -z ${__confirm__} && read -n 1 -p 'Are you sure? Y|n ' __confirm__ && echo
  case $__confirm__ in n|N) return;; esac
  "$@"
}

function __sub {
  __parent__=$__task__
  __run $@
}

function __run {
  : 'Usage: > __run [task] [args..]'
  __task__=$1
  __fn_prefix=''
  shift
  __process
  local func=${__fn_prefix}${__task__}__
  __exists ${func} || return
  __puton__ "$@" && ${func} "$@" && __takeoff__ "$@"
}

function __process {
  if [ -z $__task__ ]; then
    __fn_prefix=''
    __task__='__main'
  elif [ ! -z $__parent__ ]; then
    __fn_prefix=${__parent__}__
  fi
}

function __exists {
  : 'Usage: > __exists $fname # Returns false if $fname is not a function.'
  typeset -F $1 >/dev/null || __return $__err_fn_na $1
}

function __return {
  read -r number info <<< $@
  __return_info=$info
  return $number
}

function __tasks {
  test -z $__parent__ || prefix=${__parent__}__
  typeset -F | cut -d' ' -f3- | grep ^${prefix}[^__][^__]*__$ | sort | sed 's|__| |g' | sed "s|$__parent__\s||g"
}

__main__help=${__main__help:-''}
__exists __main__ ||
function __main__ {
  : 'display help if __main__ is not defined.'
  help__ "$@"
}

help__help=${help__help:-'Usage: __app__ help [task]'}
__exists help__ ||
function help__ {
  if [ -n "$1" ] && __exists ${1}__; then
    local task=$1
    printf '# %s\n\n' "$(__help $task)"
    declare -f ${task}__
    return
  fi
  [[ -n $__main__help ]] && printf '%s\n\n' "$__main__help"
  if [ ! -z $__id__ ]; then
    echo 'Usage:'
    printf ' %s %s %s [task]\n\n' $(basename $__app__) ${__id__:-'[id]'} ${__parent__}
  fi
  echo 'Available tasks:'
  for task in $(__tasks); do
    printf ' - %-10s# %s\n' $task "$(__help $task)"
  done
}

__puton__help='Return false to stop the application.'
__exists __puton__ ||
function __puton__ {
  : ${__app__} help ${FUNCNAME::-2}
}

__takeoff__help='Called if the task callback returns success.'
__exists __takeoff__ ||
function __takeoff__ {
  : ${__app__} help ${FUNCNAME::-2}
}

__fallbck__help='Called if the task is not found or the last command returns non-zero.'
__exists __fallback__ ||
function __fallback__ {
  case $? in
    $__err_fn_na)
      echo >&2 "task $__return_info wasn't found."
      help__
      ;;
    *)
      >&2 __help $__task__
  esac
}

function __ {
  __app__=${__app__:-$0}
  __src__=$0
  : '$ undies -- /path/to/undies'
  if [ "$1" = "--" ] && [ -e "$2" ]; then
    shift
    __src__=$(dirname $1)/$(basename $1)
    __=! source $__src__
    __app__="$__app__ $__src__"
    shift
  fi
  if [ ! -z $__id__ ]; then
    __id__=$1
    shift
  fi
  __run "$@" || __fallback__ "$@" || >&2 echo 'failed to __run '$@
}

[[ "$__" = __ ]] || return

__ "$@"
