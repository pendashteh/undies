#!/usr/bin/env bash

__="__"

__API=2

__confirm__=${__confirm__:-'1'}

function __help {
  help_var=${1}__help
  sed "s|__app__|$__app__|g" <<<${!help_var}
}

function __exec {
  : 'Usage: > __exec [bash commands] # prompts the commands for the user and executes them'
  echo "> $@"
  test -n ${__confirm__} && read -n 1 -p 'Are you sure? Y|n ' __confirm__
  echo ''
  case $__confirm__ in n|N) return;; esac
  "$@"
}

function __run {
  : 'Usage: > __run [task] [args..]'
  local task=${1:-'--'}; shift
  test "$task" = '--' && task='__main'
  test ! -z "$task" && __exists ${task}__ && __task__=$task || return 1
  __puton__ "$@" && ${__task__}__ "$@" && __takeoff__ "$@"
}

function __exists {
  : 'Usage: > __exists $fname # Returns false if $fname is not a function.'
  typeset -F $1 >/dev/null || return 1
}

function __tasks {
  typeset -F | cut -d' ' -f3- | grep ^[^__]*__$ | sort | sed 's|__||g'
}

__main__help=${__main__help:-''}
__exists __main__ ||
function __main__ {
  : 'display help if __main__ is not defined.'
  __run help "$@"
}

help__help=${help__help:-'Usage: __app__ help [task]'}
__exists help__ ||
function help__ {
  if [ -n "$1" ] && __exists ${1}__; then
    local task=$1
    printf '# %s\n\n' "$(__help $task)"
    declare -f ${task}__
    return
  fi
  [[ -n $__main__help ]] && printf '%s\n\n' "$__main__help"
  printf 'Usage: %s [task]\n\n' "$__app__"
  echo 'Tasks:'
  for task in $(__tasks); do
    printf ' - %s\t# %s\n' $task "$(__help $task)"
  done
}

__puton__help='Return false to stop the application.'
__exists __puton__ ||
function __puton__ {
  : ${__app__} help ${FUNCNAME::-2}
}

__takeoff__help='Called if the task callback returns success.'
__exists __takeoff__ ||
function __takeoff__ {
  : ${__app__} help ${FUNCNAME::-2}
}

function __ {
  __app__=${__app__:-$0}
  __src__=$0
  if [ -e "$1" ]; then
    __src__=$(dirname $1)/$(basename $1)
    source $__src__
    __app__="$__app__ $__src__"
    shift
  fi
  __run "$@" || : 'failed to __run '$@
}

__ "$@"
